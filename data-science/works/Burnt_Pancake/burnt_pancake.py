# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nfggivjvxYEuZ-H_KGcMqKdubZrD7rOQ
"""

# Flip

def flip(state, position):
    flipped = ""

    # reverse the order and change side
    for i in range(position):
        flipped += state[position*2-2*i-2]

        side = state[position*2-2*i-1]
        if side == 'w':
            flipped += 'b'

        else:
            flipped += 'w'

    flipped += state[position*2:]
    return flipped


# Heuristic
def heuristic(state):
    goal = "1w2w3w4w"

#Pancake 1 should be at index 0
#Pancake 2 should be at index 2
#Pancake 3 should be at index 4
#Pancake 4 should be at index 6.

    correct = [0, 2, 4, 6]

    for i in range(4, 0 , -1):

        if state.index(str(i )) !=correct[i-1]:

            return i
    return 0


def bubble_sort(queue):
    n = len(queue)

    for i in range(n):
        for j in range(0, n-i-1):

            if queue[j][0] > queue[j+1][0]:
                queue[j], queue[j+1] = queue[j+1], queue[j]

# A*
def astar(start):
    goal = "1w2w3w4w"

    # generate
    queue = [(heuristic(start), 0, start, [])]
    visited = [start]  # track visited

    while len(queue) > 0:

        bubble_sort(queue)

        f, g, current_state,path = queue.pop(0)

        # Check if it is the goal
        if current_state ==goal:
            return path + [(current_state, "g")]

        # find neighbors
        for flip_position in range(1, 5):
            next_state =flip(current_state, flip_position)


            if next_state not in visited:
                visited.append(next_state)
                h = heuristic(next_state)
                new_g = g+ flip_position
                queue.append((new_g+ h, new_g, next_state, path+ [(current_state, flip_position)]))

    return None

# BFS algorithm
def bfs(start):
    goal = "1w2w3w4w"

    # Initialize queue
    queue = [[start, []]]
    visited = [start]

    while len(queue) > 0:

        current_state, path =queue.pop(0)


        if current_state == goal:
            return path +[(current_state, "g" )]


        for flip_position in range(1, 5):
            next_state = flip(current_state, flip_position)

            # if not visited
            if next_state not in visited:
                visited.append( next_state)
                queue.append([next_state, path + [ (current_state, flip_position) ]])

    return None

# print A*
def printa(solpath):

    g = 0  # declare g

    for state, flip in solpath:
        if flip == "g":
            print(state + " g:" + str(g) + ", h:0" )

        else:
            h = heuristic(state)
            print(state[:flip*2] + "|" + state[flip*2:], "g:" + str(g) + ", h:" + str(h))
            g += flip  # Update g after printing

#  print bfs
def printb(solpath):
    for state, flip in solpath:
        if flip == "g":
            print(state)  #goal state
        else:
            print(state[:flip*2] + "|" + state[flip*2:])

# let user input
user_input = input("input     ")


initial_state = user_input[:-2]
algorithm = user_input[-1]


if algorithm == 'b':
    solpath = bfs(initial_state)
    printb(solpath)

elif algorithm == 'a':
    solpath = astar(initial_state)
    printa(solpath)
